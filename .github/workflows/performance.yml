name: Performance & Benchmarks

on:
  push:
    branches: [ main, dev ]
  pull_request:
    branches: [ main, dev ]
  schedule:
    - cron: '0 2 * * 1'  # Weekly on Monday at 2 AM UTC

env:
  CACHE_VERSION: v1

jobs:
  performance-test:
    name: Performance Testing
    runs-on: ubuntu-latest
    container:
      image: ubuntu:24.04

    steps:
    # Cache APT packages
    - name: Cache APT packages
      uses: actions/cache@v4
      with:
        path: /var/cache/apt
        key: apt-perf-${{ runner.os }}-${{ env.CACHE_VERSION }}
        restore-keys: |
          apt-perf-${{ runner.os }}-

    - name: Install dependencies
      run: |
        apt-get update -qq
        apt-get install -y \
          build-essential \
          cmake \
          git \
          pkg-config \
          libudev-dev \
          libevdev-dev \
          qt6-base-dev \
          qt6-bluetooth-dev \
          valgrind \
          time \
          bc \
          ccache

    - name: Checkout code
      uses: actions/checkout@v4

    # Cache build artifacts for performance testing
    - name: Cache performance build
      uses: actions/cache@v4
      with:
        path: |
          build/
          ~/.ccache
        key: perf-build-${{ runner.os }}-${{ hashFiles('CMakeLists.txt', 'src/**') }}-${{ env.CACHE_VERSION }}
        restore-keys: |
          perf-build-${{ runner.os }}-

    - name: Build optimized release
      run: |
        mkdir -p build
        cd build
        cmake .. \
          -DCMAKE_BUILD_TYPE=Release \
          -DCMAKE_CXX_FLAGS="-O3 -march=native" \
          -DBUILD_TESTS=ON \
          -DCMAKE_C_COMPILER_LAUNCHER=ccache \
          -DCMAKE_CXX_COMPILER_LAUNCHER=ccache
        make -j$(nproc)

    - name: Memory leak detection with Valgrind
      run: |
        cd build
        # Run basic memory leak detection on test binaries
        echo "ðŸ§ª Running memory leak detection..."
        
        valgrind \
          --tool=memcheck \
          --leak-check=full \
          --show-leak-kinds=all \
          --track-origins=yes \
          --verbose \
          --error-exitcode=1 \
          --suppressions=/dev/null \
          ./test_device_manager 2>&1 | tee valgrind-device-manager.log
        
        valgrind \
          --tool=memcheck \
          --leak-check=full \
          --show-leak-kinds=all \
          --track-origins=yes \
          --verbose \
          --error-exitcode=1 \
          --suppressions=/dev/null \
          ./test_args 2>&1 | tee valgrind-args.log

    - name: CPU profiling with Callgrind
      run: |
        cd build
        echo "ðŸ“Š Running CPU profiling..."
        
        # Profile the args test (lightweight)
        valgrind --tool=callgrind --callgrind-out-file=callgrind.args.out ./test_args
        
        # Profile the device manager test
        valgrind --tool=callgrind --callgrind-out-file=callgrind.device-manager.out ./test_device_manager

    - name: Binary size analysis
      run: |
        cd build
        echo "ðŸ“ Analyzing binary sizes..."
        
        ls -lh ninja_util test_* > binary-sizes.txt
        
        # Calculate sizes
        MAIN_SIZE=$(stat -c%s ninja_util)
        echo "Main binary size: $MAIN_SIZE bytes ($(echo "scale=2; $MAIN_SIZE/1024/1024" | bc) MB)"
        
        # Strip binary and compare
        cp ninja_util ninja_util_stripped
        strip ninja_util_stripped
        STRIPPED_SIZE=$(stat -c%s ninja_util_stripped)
        echo "Stripped binary size: $STRIPPED_SIZE bytes ($(echo "scale=2; $STRIPPED_SIZE/1024/1024" | bc) MB)"
        
        SAVINGS=$((MAIN_SIZE - STRIPPED_SIZE))
        SAVINGS_PCT=$(echo "scale=1; ($SAVINGS * 100) / $MAIN_SIZE" | bc)
        echo "Debug info size: $SAVINGS bytes (${SAVINGS_PCT}% of total)"

    - name: Startup time benchmark
      run: |
        cd build
        echo "â±ï¸  Benchmarking startup time..."
        
        # Benchmark help command (quick exit)
        echo "Testing --help command:"
        for i in {1..10}; do
          /usr/bin/time -f "%e" ./ninja_util --help 2>&1 | tail -1
        done | tee startup-times.txt
        
        # Calculate average
        AVG=$(awk '{sum += $1; count++} END {print sum/count}' startup-times.txt)
        echo "Average startup time: ${AVG} seconds"

    - name: Upload performance artifacts
      uses: actions/upload-artifact@v4
      with:
        name: performance-results
        path: |
          build/valgrind-*.log
          build/callgrind.*.out
          build/binary-sizes.txt
          build/startup-times.txt
        retention-days: 30

  static-analysis:
    name: Static Analysis
    runs-on: ubuntu-latest
    container:
      image: ubuntu:24.04

    steps:
    - name: Install dependencies
      run: |
        apt-get update
        apt-get install -y \
          build-essential \
          cmake \
          git \
          pkg-config \
          libudev-dev \
          libevdev-dev \
          qt6-base-dev \
          qt6-bluetooth-dev \
          clang-tools \
          iwyu

    - name: Checkout code
      uses: actions/checkout@v4

    - name: Build with compile commands
      run: |
        mkdir build
        cd build
        cmake .. \
          -DCMAKE_BUILD_TYPE=Debug \
          -DCMAKE_EXPORT_COMPILE_COMMANDS=ON \
          -DBUILD_TESTS=ON

    - name: Include What You Use analysis
      run: |
        cd build
        echo "ðŸ” Running Include What You Use analysis..."
        
        # Run IWYU on source files
        iwyu_tool.py -p . ../src/ -- \
          -Xiwyu --mapping_file=../iwyu.imp \
          -Xiwyu --no_fwd_decls \
          > iwyu-results.txt 2>&1 || true
        
        echo "IWYU analysis complete. Results:"
        head -50 iwyu-results.txt

    - name: Dead code detection
      run: |
        echo "ðŸ§¹ Checking for unused functions..."
        
        # Build with coverage flags to detect unused code
        cd build
        cmake .. \
          -DCMAKE_BUILD_TYPE=Debug \
          -DCMAKE_CXX_FLAGS="--coverage -fprofile-arcs -ftest-coverage" \
          -DBUILD_TESTS=ON
        make -j$(nproc)
        
        # Run tests to generate coverage
        ctest
        
        # Generate coverage report
        find . -name "*.gcda" -exec gcov {} \; > coverage-summary.txt 2>&1

    - name: Upload static analysis results
      uses: actions/upload-artifact@v4
      with:
        name: static-analysis-results
        path: |
          build/iwyu-results.txt
          build/coverage-summary.txt
        retention-days: 30
